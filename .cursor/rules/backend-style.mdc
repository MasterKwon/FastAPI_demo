---
description: 
globs: 
alwaysApply: false
---

## 🧱 아키텍처 가이드라인

1. FastAPI의 *Dependency Injection* 시스템을 활용해 상태나 리소스를 관리합니다.
2. API 성능 지표(응답 속도, 지연, 처리량)를 모니터링합니다.
3. 라우트 내에서는 블로킹 연산을 피합니다:
   - 비동기 처리를 우선합니다.
   - DB, 외부 API 연산은 별도 함수로 분리하여 관리합니다.
   - 라우트와 의존성 구성을 명확히 하여 가독성과 유지보수성을 확보합니다.

---

## 🗄️ 데이터베이스 스키마 관리

- 데이터베이스 스키마는 `database/schema.sql` 파일에서 관리됩니다.
- SQL 파일은 직접 수정하지 않고 참조만 합니다.
- 새로운 모델 생성/수정 시:
  1. SQL 파일의 테이블 구조를 먼저 확인
  2. 해당 구조에 맞춰 Pydantic 모델 생성/수정
  3. 필요한 경우 모델에 대한 추가 설명 요청
- 테이블 구조 변경이 필요한 경우 먼저 논의 후 진행
- 모델과 실제 DB 스키마의 일관성 유지

---

## 📊 엑셀 데이터 처리

- 엑셀 파일 처리 시 컬럼명 대신 컬럼 순서를 기반으로 처리합니다.
- 컬럼 순서는 0부터 시작하는 인덱스를 사용합니다.
- 엑셀 파일의 구조가 변경될 경우 순서만 유지되면 코드 수정이 필요 없도록 설계합니다.
- 데이터 매@핑은 명시적인 인덱스 기반으로 처리합니다.

예시:
```python
# 권장하는 방식
def process_excel_row(row: List[str]) -> Dict:
    return {
        "name": row[0],      # 첫 번째 컬럼
       @ "age": int(row[1]),  # 두 번째 컬럼
        "email": row[2]      # 세 번째 컬럼
    }

# 피해야 할 방식
def process_excel_row(row: Dict) -> Dict:
    return {
       @ "name": row["이름"],     # 컬럼명 직접 참조
        "age": int(row["나이"]), # 컬럼명 직접 참조
        "email": row["이메일"]   # 컬럼명 직접 참조
    }
```

---

📚 참고: @FastAPI 공식 문서

## 프로젝트 구조변경에 따른 import 경로 변경
- import 경로를 변경할 때는 **경로만 변경**하고, 클래스나 함수의 구조(시그니처, 동작 방식)는 절대 변경하지 않습니다.
- 예를 들어, `from app.utils.logger import app_logger, LogType`를 `from backend.utils.logger import app_logger, LogType`로 변경할 때, 나머지 코드는 그대로 유지합니다.

---

## SQL Query Implementation
- Raw SQL 쿼리 사용 (ORM 사용하지 않음)
- 쿼리는 `queries/` 디렉토리에 도메인별로 분리하여 관리
- 각 쿼리 함수는 하나의 SQL 쿼리만 실행
- 쿼리 함수명은 동작을 명확히 표현
- 파라미터는 딕셔너리 형태로 전달
- 쿼리 결과는 명시적인 타입으로 반환






